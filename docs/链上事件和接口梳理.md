# 首页看板

## 表格字段

- **昨日注册人数：没有链上事件和查询接口。**
- 昨日交易额（USDT）

```
链上事件（推荐）：EventBatchSpotExecution（trades[] 里有 quantity 和 price），对每笔成交计算 amount_quote=quantity×price，再按市场 quote denom 汇总
只做现货：仅统计 spot market 的 market_id
建议：用事件监听做按日聚合表
```

- 昨日订单数：

```
链上事件（推荐）：用 tx 事件过滤 message.action 统计“下单消息”数量
覆盖现货+杠杆：MsgCreateSpotLimitOrder/MsgCreateSpotMarketOrder + MsgCreateSpotLeverageLimitOrder/MsgCreateSpotLeverageMarketOrder（以及批量下单的 msg）
建议：事件监听 + 按日计数
```

- 昨日充值（USDT）

```
链上事件（推荐）：EventSubaccountDeposit（钱包 → 交易子账户）
若充值包含多币种但要求统一转 USDT，需要价格换算
建议：事件 + oracle Query + 链下换算
```

- 昨日提现（USDT）

```
链上事件（推荐）：EventSubaccountWithdraw（交易子账户 → 钱包）
若提现包含多币种但要求统一转 USDT，需要价格换算
建议：事件 + oracle Query + 链下换算
```

- **总注册人数：没有链上事件和查询接口。**
- 总交易额

```
链上 Query（可直接拿累计值，推荐）：Query.AggregateMarketVolumes（传入所有 spot market_ids）
汇总 maker_volume + taker_volume 得到全平台累计成交额（quote 计价，若全部是 *-USDT 市场就天然是 USDT）
```

- 总订单数

```
链上事件（推荐）：同“昨日订单数”用 tx message.action 统计累计
```

- 总充值 / 总提现

```
链上事件（推荐）：累计汇总 EventSubaccountDeposit/EventSubaccountWithdraw
```

- 交易量趋势（7D/30D/90D）

```
链上事件（推荐）：同“昨日交易额”，落 daily_trade_volume，图表直接读
```

- **注册人数趋势：链上不支持**

==数据更新时间==

实现建议：链下定时任务（每小时）读“昨日/总量/趋势”聚合表，前端展示 last_updated_at

# 用户管理

## 表格字段

- **用户 ID：链上不支持**

```
建议：保留 U001 这类用户ID（可行）：必须自建 user_id -> subaccount_id 映射
```

- 地址：子账户/交易账户地址 = subaccount_id

```
链上事件（可得）：可从以下事件里抓到并沉淀为“用户集合”
	EventSubaccountDeposit.subaccount_id
	EventSubaccountWithdraw.subaccount_id
	EventBatchSpotExecution.trades[].subaccount_id
	现货杠杆借/还（SDK 事件）：spot_leverage_borrow / spot_leverage_repay（attributes：subaccount_id）
	（注意：proto/injective/exchange/v2/spot_leverage.proto 虽定义了 EventBorrow/EventRepayBorrow，但当前链端代码实际 Emit 的是上述 SDK 事件字符串）
建议：用事件索引生成 subaccount_id 列表
```

- **邮箱：链上不支持**

```
需要和前端进行配合
```

- **注册时间：链上不支持**

```
无“注册”概念，但可定义为首次活跃时间
实现：对每个 subaccount_id 记录首次出现的区块时间（首次入金/首次下单/首次成交）
```

- 总估值（USDT）

```
链上 Query（推荐）：Query/RiskMetrics(subaccount_id) → RiskMetrics.total_asset_value（proto 注释明确：USDT计价）
建议：列表页用 RiskMetrics 的 total_asset_value；如果要更快，需要链下缓存/定时刷新（否则 N 个用户要打 N 次 Query）
```

- 总转入（USDT）

```
链上事件（可得，但需聚合）：监听 EventSubaccountDeposit.amount 按 subaccount_id 累加
建议：全币种折算USDT。需要链下在处理事件时同时记录“当时折算价”（链上 Query 通常只有现价，历史价要自己落库/快照），或补链上“历史价查询接口”
```

- 总转出（USDT）

```
链上事件（可得，但需聚合）：监听 EventSubaccountWithdraw.amount 按 subaccount_id 累加
建议：同“总转入”的口径选择（折算USDT）
```

- 已实现盈亏（USDT）

```
链上事件（可得，但需复杂二次加工）：
成交来自 EventBatchSpotExecution{market_id, trades[]}（TradeLog 有 price/quantity/fee/order_hash/subaccount_id），需要在链下维护“持仓/成本价/成交明细”，才能把每次减仓/平仓的部分算成已实现盈亏。
建议：链下聚合（推荐）：基于成交事件做成本法（FIFO/均价法二选一）+ 扣手续费
```

- 未实现盈亏（USDT）

```
链上 Query（可得）：Query/SpotLeverageAccount(subaccount_id) → SpotLeverageAccount.positions[].unrealized_pnl（按 market 汇总）
建议：列表页可直接 sum positions 的 unrealized_pnl；若 account=nil（未启用杠杆）则展示 0 或 “-”
```

- **利息（累计支付利息(USDT)）**

```
链上 Query（部分可得）：可取“当前应计未付利息”，但产品要求的是累计支付利息
建议有两个：
（1）链下可做但较重：用 spot_leverage_borrow / spot_leverage_repay（SDK 事件）+ 借贷利率快照（Query/LendingRateHistory）在链下对每个借款人做逐小时计息与摊销，得到“累计支付利息”
    备注：borrow 事件包含 prepaid_interest（预收1小时利息）；repay 事件目前只给 amount（本金+利息总额），无法直接拆分“本次支付利息”。
（2）改链补事件/接口（推荐）：让 spot_leverage_repay（或改为 EmitTypedEvent 的 EventRepayBorrow）额外携带 principal_repaid 和 interest_repaid（或新增 Query 返回累计利息），这样链下汇总会非常简单。
```

- **状态（正常/禁用交易）**

```
目前链上无法做到，需要新账户体系下的接口支持
```

## 弹窗按钮

- **禁用交易/解除禁用**

```
目前链上不支持，和状态一样，需要新账户体系下的接口支持
```

# 交易对管理

## 表格字段

- **序号：链上不提供（纯 UI 字段）**

```
最佳做法：按排序规则（例如 ticker 排序/创建先后）在前端生成行号即可
```

- 交易对

```
链上 Query（可直接拿）：SpotMarket.ticker（格式是 AAA/BBB）
```

- taker 手续费

```
Query：SpotMarket.taker_fee_rate
```

- maker 手续费

```
Query：SpotMarket.maker_fee_rate
```

- 交易币种

```
Query：SpotMarket.base_denom
注意/建议：
链上给的是 denom，如果 denom 本身不是你们想展示的“符号”（如 factory/...），仅靠 exchange 模块拿不到“股票代码/展示名”。
可行建议：需要自建一份 denom -> symbol 的 registry（不影响“数据来源”，只是展示映射）
```

- 结算币种

```
Query：SpotMarket.quote_denom
注意/建议：
链上给的是 denom，如果 denom 本身不是你们想展示的“符号”（如 factory/...），仅靠 exchange 模块拿不到“股票代码/展示名”。
可行建议：需要自建一份 denom -> symbol 的 registry（不影响“数据来源”，只是展示映射）
```

- 更新时间

```
事件（最佳）：监听 EventSpotMarketUpdate，用该事件所在区块的 block_time 作为“更新时间”，并在链下落库 market_id -> last_updated_at
```

- 当前状态

```
Query：SpotMarket.status（MarketStatus：Active/Paused/Demolished/Expired），状态我们只要正常交易，下架中。
映射建议：
Active → 正常交易
Paused/Demolished/Expired → 下架中
```

## 弹窗按钮

- 查看详情

  - 交易代码，同上面的交易对
  - 状态，同上面的当前状态
  - 交易币种，同上面的交易对（前半部分）
  - 结算币种，同上面的交易对（后半部分）
  - taker 手续费率，同上面 taker 手续费率
  - maker 手续费率，同上面 maker 手续费率
  - 价格步长

  ```
  Query injective.exchange.v2.Query/SpotMarket(s)
  链上字段：SpotMarket.min_price_tick_size
  ```

  - 数量步长

  ```
  Query injective.exchange.v2.Query/SpotMarket(s)
  链上字段：SpotMarket.min_quantity_tick_size
  ```

  - 最小金额

  ```
  Query injective.exchange.v2.Query/SpotMarket(s)
  链上字段：SpotMarket.min_notional（quote 计价、human readable）
  ```

  - **金额步长/最小数量/最大数量/最大金额：链上没有相关字段**

  ```
  产品要求，补链上相关字段
  金额步长 -> amount_tick_size
  最小数量 -> min_quantity
  最大数量 -> max_quantity
  最大金额 -> max_notional

  链端补齐之后，需要在查询 Query injective.exchange.v2.Query/SpotMarket(s) 和事件 EventSpotMarketUpdate 中返回/携带这些字段！！！
  ```

  - **做多初始保证金/做空初始保证金/做多维持保证金/做空维持保证金**

  ```
  链上目前不区分具体的做多和做空，产品允许它俩一致，也就是做多和做空初始保证金用一样的就行，同样，做多和做空的维持保证金也用一样的就行。
  ```

  - **创建时间/更新时间**

  ```
  链上没有这两个字段，需要补链
  创建时间 -> create_time
  更新时间 -> update_time

  如果是链上创建的，用链上block_time即可。如果是通过 dex 平台创建并上链的，就用系统时间即可。
  ```

  ==特别说明==

  查看详情是查看某一个交易对的各种参数，该交易对肯定已经上链了。查看详情中有一个“编辑”按钮，可以对参数进行修改，修改后保存是要上链同步的，并不仅仅是更新到数据库中，链端也要同步。

- 添加交易对

  ```
  添加交易对弹窗里面的所有字段和“查看详情”一模一样，唯一不同的是没有“创建时间”和“更新时间”这两个字段，但不代表不用填，直接用系统时间即可。
  ```

- 上架/下架

  ```
  上架和下架本质上就是改变链上市场的状态，和前面的“状态”字段相对应，分为“正常交易”和“下架中”，需要同步链上。
  ```

==特别说明==

添加交易对是创建一个新的市场，需要上链。查看详情中的编辑，是对链上已有市场的修改，改完后需要上链。上架和下架也是需要同步链上的，所以这些按钮都需要走提案签名验证。

# 订单管理

## 普通订单

### 表格字段

- **序号：链上无此字段**

```
前端列表行号/服务端排序后行号（纯展示字段）
```

- **用户 ID：链上不支持**

```
最优来源：事件
EventNewSpotOrders 里的 SpotLimitOrder.order_info.subaccount_id；或 EventBatchSpotExecution.trades[].subaccount_id
可行性建议：若必须保留 U001，只能链下维护 U001 -> subaccount_id 映射（不属于链上可直接取）
```

- 订单 ID

```
最优来源：事件
EventNewSpotOrders.buy_orders/sell_orders[].order_hash
EventCancelSpotOrder.order.order_hash
EventBatchSpotExecution.trades[].order_hash
```

- 交易对代码

```
链上原始关联键：订单事件里给的是 market_id
最优：用 Query 把 market_id -> ticker 映射一次并缓存
injective.exchange.v2.Query/SpotMarket 或 SpotMarkets 返回 SpotMarket.ticker（AAA/BBB），前端可转成 AAA-BBB
```

- 订单类型

```
最优（事件推断）：
出现在 EventNewSpotOrders 的 = LIMIT（限价单）
只出现在成交（EventBatchSpotExecution）且无新单事件的 = MARKET（市价单，通常立即成交）
```

- 交易方向

```
最优来源：事件
限价单：EventNewSpotOrders.buy_orders / sell_orders（或 SpotLimitOrder.order_type）
成交：EventBatchSpotExecution.is_buy（该批 trades 对应方向）
```

- 订单状态

```
最优（事件状态机）：
收到 EventNewSpotOrders：状态=待成交
收到 EventCancelSpotOrder：状态=已撤销
处理 EventBatchSpotExecution 累加成交量；当 成交量 >= 委托数量：状态=已成交
```

- **下单失败 / 撤单失败（可选补充）**

```
在“批量下单/撤单”场景中，链端会发更细粒度的失败事件，适合后台做“失败原因/失败明细”：

1）下单失败（尤其 MsgBatchCreateSpotLimitOrders）：
链上事件：injective.exchange.v2.EventOrderFail
返回字段：account / hashes / flags / cids（flags 通常可视为 ABCI code）

2）撤单失败：
链上事件：injective.exchange.v2.EventOrderCancelFail
返回字段：market_id / subaccount_id / order_hash / cid / description

备注：如果产品不展示“失败订单”，可以不采集；但用于风控/运营排障非常有价值。
```

- 成交量

```
最优：事件聚合 EventBatchSpotExecution.trades[].quantity（按 order_hash 求和）
```

- 成交额

```
最优：事件聚合 EventBatchSpotExecution.trades[]
对每条 trade：amount=quantity×price
按 order_hash 求和得到该订单成交额
```

- **已实现盈亏：链上暂不支持**

```
可行性建议
1、链下二次加工：基于成交事件维护持仓与成本（均价/FIFO 二选一）并在平仓/减仓时计算 realized pnl；若计入杠杆利息，还需结合 spot_leverage_borrow / spot_leverage_repay 做利息摊销（repay 事件 amount 不拆本金/利息）
2、补链：扩展现货执行事件/TradeLog，增加可验证的 realized_pnl（实现成本最高，但链下最省）
```

- 下单时间

```
最优：用事件所在区块时间作为下单时间
限价单：EventNewSpotOrders 所在 block_time
市价单：对应成交事件所在 block_time（或你在交易解析时用 tx 的 block_time）
```

### 弹窗按钮

- 成交明细

  - 订单信息（订单 ID）：同上面订单 ID
  - 订单信息（交易对）：同上面交易对代码
  - 订单信息（订单类型）：同上面订单类型
  - 订单信息（交易方向）：同上面交易方向
  - 价格与数量（委托价）

    ```
    限价单最优：SpotLimitOrder.order_info.price（来自 EventNewSpotOrders 事件）
    市价单：链上没有“委托价”概念 → 建议显示 -
    ```

  - 价格与数量（成交均价）

    ```
    链上最优：基于逐笔成交记录计算
    计算：avgPrice=∑(q×p)/∑(q)，数据来自 EventBatchSpotExecution.trades[]
    ```

  - 价格与数量（委托数量）

    ```
    限价单最优：SpotLimitOrder.order_info.quantity（EventNewSpotOrders）
    市价单可行性建议：
    若你们落库时能解析创建订单的 tx 消息（链上 tx 查询）→ 用消息里的 order.order_info.quantity
    ```

  - 价格与数量（成交数量）

    ```
    链上最优：对该 order_hash 的所有 TradeLog.quantity 求和（来自 EventBatchSpotExecution.trades[]）
    ```

  - 价格与数量（委托金额）

    ```
    限价单最优：order_price * order_quantity（链下计算）
    市价单建议：展示为"成交金额"或 -
    ```

  - 价格与数量（成交金额）

    ```
    链上最优：对该 order_hash 的所有成交 q×p 求和（链下计算；q/p 来自 TradeLog）
    ```

  - **价格与数量（成本价）**

    ```
    链上没有
    可行性建议：必须链下维护用户持仓与成本（均价/FIFO 二选一），才能给“成本价”
    ```

  - **价格与数量（已实现盈亏）**

    ```
    链上没有
    可行性建议：
    纯现货：基于链下成本法在“减仓/平仓”时计算
    现货杠杆：若要把利息计入盈亏，还需把 spot_leverage_borrow / spot_leverage_repay 的利息部分做摊销（repay 事件 amount 不拆本金/利息，精确口径会更重）
    ```

  - 逐笔成交记录（成交时间）

    ```
    来源：成交事件所在 tx 的 block_time（链上事件本身不带 timestamp）
    ```

  - 逐笔成交记录（成交价格 / 成交数量）

    ```
    来源：EventBatchSpotExecution.trades[].price / quantity
    ```

  - 逐笔成交记录（成交金额）

    ```
    来源：链下计算 quantity * price
    ```

  - 逐笔成交记录（手续费）

    ```
    来源：EventBatchSpotExecution.trades[].fee
    注意：如果你们所有市场 quote 都是 USDT，基本可直接展示；若存在非 USDT quote，需要链下做折算
    ```

  - 逐笔成交记录（哈希）

    ```
    链上现状：TradeLog 里没有 tx hash 字段
    最优做法：在监听 tx 事件时，把当前 tx hash写入每条成交记录（同一笔 tx 可能包含多个 trade log；不同 block/tx 的部分成交会自然对应不同 hash）
    ```

## 条件订单

==特殊说明==

目前现货杠杆功能暂时不支持止盈止损类型订单的筛选，链上也没有对应的获取方式。如果要做，需要改链端，重新设计现货杠杆功能。产品的反馈是和合约一起做，这个模块可以先不做。

## 充值管理

### 表格字段

- 充值订单号

```
最优做法（链上可得）：用 tx_hash 作为充值订单号（监听到 EventSubaccountDeposit 时把所在交易的哈希一起落库）
```

- **用户 ID：链上不支持**

```
最优做法（按你当前口径）：用 subaccount_id 作为“用户标识”
然后需要自建 Uxxx <-> subaccount_id 映射表
```

- 币种

```
事件最优：EventSubaccountDeposit.amount.denom
可行性建议：PRD 展示 USDT/AAPL 这类 symbol，链上给的是 denom（如 inj、tokenfactory/...），需要你们做 denom→symbol 映射
```

- 到账金额

```
事件最优：EventSubaccountDeposit.amount.amount（链上最小单位）
可行性建议：展示到小数需要 decimals（可从市场 SpotMarket.base/quote_decimals 或你们自维护的 token decimals）
```

- **充值时间：链上没有**

```
建议使用前端用户点击充值的系统时间
```

- 到账时间

```
事件最优：EventSubaccountDeposit 所在交易的 block_time
```

- 状态

```
根据产品要求，只保留成功和失败
1、已确认（完成）：监听到 EventSubaccountDeposit 即可判定（成功）
2、失败：需要补查该笔 MsgDeposit 的交易执行结果（tx.code != 0），用链的 Tx 查询接口（gRPC 或 Tendermint TxSearch）实现
```

### 弹窗按钮

- 查看详情

  - 充值订单号：同上面的充值订单号
  - 用户 ID：同上面的用户 ID
  - 币种：同上面的币种
  - 到账金额：同上面的到账金额
  - 充值时间：同上面的充值时间
  - 到账时间：同上面的到账时间
  - 状态：同上面的状态
  - 充值地址

    ```
    链上最优来源：事件 injective.exchange.v2.EventSubaccountDeposit.subaccount_id（也就是交易账户地址）
    ```

  - 交易哈希

    ```
    链上最优来源：在监听到 EventSubaccountDeposit 时，同时把该笔交易的 tx_hash从交易执行结果里取出并落库（事件本身不带 tx_hash 字段）
    可行性：需要用链的 Tx 查询/索引能力（如 Tendermint/CometBFT TxSearch 或 gRPC Tx Service）来拿到 hash、height、code、raw_log
    ```

  - **网络协议**

    ```
    链上现状：你们现在的充值定义是“同链钱包→子账户（MsgDeposit）”，没有 ERC-20 这类“网络协议”
    最佳建议：固定展示 Injective / chain-id（配置项或节点信息查询得到）
    ```

  - 区块确认数

    ```
    链上获取方式：confirmations = latest_height - tx_height + 1（tx_height 来自该笔交易；latest_height 来自最新区块查询）
    ```

  - **备注**

    ```
    链上现状：没有“业务备注”字段
    可行性建议：自动备注（推荐）：由 tx.code / raw_log 生成（成功=“充值成功”，失败=错误原因）
    ```

## 提现管理

### 表格字段

- 提现 ID

```
最佳链上替代：用 tx_hash 作为提现ID（监听到 EventSubaccountWithdraw 时把该笔交易 hash 一起落库）
```

- **用户 ID：链上不支持**

```
最佳链上替代：用 subaccount_id 作为用户标识
然后需要自建 Uxxx <-> subaccount_id 映射表
```

- 币种

```
事件最优：EventSubaccountWithdraw.amount.denom
```

- **协议**

```
链上现状：同链提现没有 ERC-20/TRC-20 这类协议字段
最佳建议：固定展示 Injective（或 chain-id）
```

- 提现金额

```
事件最优：EventSubaccountWithdraw.amount.amount（链上最小单位；展示需 decimals）
```

- **手续费（产品去掉了这个字段）**
- **实际到账**

```
实际到账 = 提现金额 - 手续费
可行性建议：补链（把业务手续费从提现额中扣除）
```

- 提现地址

```
链上最优来源：事件 injective.exchange.v2.EventSubaccountWithdraw.subaccount_id（也就是交易账户地址）
```

- 状态

```
根据产品要求，只保留成功和失败
成功：监听到 EventSubaccountWithdraw（=成功执行）
失败：通过 Tx 查询该笔 MsgWithdraw 的 tx.code != 0（链上不会发 withdraw 事件）
```

- **申请时间：链上没有**

```
建议使用前端用户点击提现的系统时间
```

- 处理时间

```
事件最优：EventSubaccountWithdraw 所在交易的 block_time
```

### 弹窗按钮

- 查看

  - 提现 ID、用户 ID、币种、网络协议、提现金额、手续费、实际到账、提现地址、申请时间、处理时间、状态，这些都是同上面的
  - 交易哈希

    ```
    链上获取（最优）：该笔 MsgWithdraw 的 tx_hash
    ```

  - 区块确认数

    ```
    链上获取（最优）：confirmations = latest_height - tx_height + 1
    （tx_height 来自该笔交易；latest_height 来自最新区块查询）
    ```

  - **处理备注**

    ```
    链上直接字段：无
    可行性建议：自动备注（不改链）：用 tx.code + raw_log 生成（成功/失败原因）
    ```

# 资金管理

## 表格字段

- **用户 ID：链上无直接字段**

```
最佳链上口径：用 subaccount_id 作为用户标识（资金管理页本质是“子账户资产”视角）

最优来源（Query）：
injective.exchange.v2.Query/BalanceWithBalanceHolds
返回字段：subaccountId（子账户ID）

可行性建议（若产品必须展示 U001 这类“用户ID”）：
仍需链下维护 Uxxx <-> subaccount_id 映射（链上无该概念）
```

- 币种

```
最佳来源（Query）：injective.exchange.v2.Query/BalanceWithBalanceHolds
返回字段：balance_with_balance_holds[].denom
备注：链上给的是 denom；展示成 USDT/AAPL 需要你们的 denom→symbol 映射
```

- 可用

```
最佳来源（Query）：injective.exchange.v2.Query/BalanceWithBalanceHolds
返回字段：balance_with_balance_holds[].available
```

- 总余额

```
最佳来源（Query）：injective.exchange.v2.Query/BalanceWithBalanceHolds
返回字段：balance_with_balance_holds[].total
```

- 冻结

```
【更新】链端现在直接给“冻结/占用”口径字段，无需再用 total-available 推导。

最佳来源（Query）：injective.exchange.v2.Query/BalanceWithBalanceHolds
返回字段：balance_with_balance_holds[].balance_hold

兼容口径（若你们暂时不接 hold 字段）：
冻结 = total - available

可选增强（适配“显示异常/对账”）：
injective.exchange.v2.Query/BalanceMismatches(dust_factor)
返回字段里包含 expected_total 与 difference，直接用于异常检测与差值展示。
```

- **估值(USDT)**

```
链上现状：没有直接“估值”字段，必须 余额 × 价格 计算
价格的最佳链上来源（建议优先级）：
1、现货市场价（推荐）：对每个 denom 找到对应 base_denom/quote_denom=USDT 的现货市场
Query/SpotMarkets 拿到市场的 market_id/base_denom/quote_denom
Query/SpotMidPriceAndTOB(market_id) 取 mid_price 作为估值价
2、预言机价（备选）：若该 denom 有 oracle，可用 oracle 模块 Query（没有就无法用）
```

- **计算余额**

```
【更新】如果该字段用于“链端对账口径”的计算余额（expected_total），链上现在可直接得到：

最佳来源（Query）：injective.exchange.v2.Query/BalanceWithBalanceHolds
计算口径：计算余额 = available + balance_hold

如果你们的“计算余额”想表达更强的“账本重放/业务流水理论余额”（而不是链端对账口径），那链上仍然没有一条 Query 直接给出：
可行性建议：链下基于链上事件做账本重放/聚合得到 computed_balance（原方案仍然成立）
至少需要监听：
1、EventSubaccountDeposit / EventSubaccountWithdraw（充提）
2、EventBatchSpotExecution（成交导致 base/quote 变化；用事件里的 is_buy + quantity + price + fee，并配合 SpotMarket.base_denom/quote_denom 计算）
3、现货杠杆相关：spot_leverage_borrow / spot_leverage_repay（借/还会改动子账户余额）
4、（可选）EventSubaccountBalanceTransfer（子账户间转账）

落地要点（建议保留）：用 EventBatchDepositUpdate 或 BalanceWithBalanceHolds 作为“链上权威余额快照”做对账校验/修正点（否则纯重放对历史全量依赖很重）
```

- **余额差**

```
【更新】若“计算余额”采用链端对账口径（available + balance_hold）：
余额差 = total - (available + balance_hold)

（可选）直接用 Query/BalanceMismatches 返回的 difference 字段作为余额差（仅返回异常行，更适合“显示异常”）
```

# 资金明细

## 表格字段

- **用户 ID**

```
最佳链上口径：用 subaccount_id 当用户标识
链下维护 Uxxx <-> subaccount_id 映射
```

- 币种

```
充值/提现：事件自带 amount.denom
买入/卖出（成交）：事件里只有 market_id，币种需要 Query SpotMarket 得到 base_denom/quote_denom，再按成交生成对应币种
```

- 操作类型（按照产品要求，只关注买入，卖出，充值，提现，利息）

```
买入/卖出：由成交事件生成；方向需要知道该 order_hash 对应的订单侧（BUY/SELL）
最稳做法：维护 order_hash -> is_buy 的索引（来自下单消息/EventNewSpotOrders 等），再给每条 TradeLog 打 BUY/SELL

充值/提现：分别来自 EventSubaccountDeposit / EventSubaccountWithdraw

利息（PRD 的“支付借款利息”）：
链上现状：没有“interest_paid=多少”的独立事件字段
可行性建议：若一定要拆出“利息”流水，需要链改在 "spot_leverage_repay" 里额外输出 interest_paid/principal_paid；否则只能把还款总额记为“还款”，或把利息并入还款流水里展示

（可选扩展：若后续产品增加“划转/转账”类型）
链上事件：injective.exchange.v2.EventSubaccountBalanceTransfer
返回字段：src_subaccount_id / dst_subaccount_id / amount
对应消息：MsgSubaccountTransfer / MsgExternalTransfer
```

- 交易金额

```
充值：+amount

提现：-amount

买入/卖出（成交）：建议按币种拆行（才能对账）
base 币种行：买入 +quantity，卖出 -quantity
quote 币种行：买入 -(quantity*price)，卖出 +(quantity*price)

手续费：不并入交易金额，放到“手续费”列
```

- **手续费**

```
现货成交：TradeLog.fee
充值：链上业务上通常为 0
提现：需要额外收取手续费，具体和产品定
```

- 手续费币种

```
现货成交：最稳用该市场的 quote_denom（从 SpotMarket 取；Injective 现货费一般计在 quote）
PRD 要“统一 USDT”：链上不保证都是 USDT，需要链下做币种换算（价格来自 SpotMidPriceAndTOB/oracle）
```

- 时间

```
最佳链上口径：该笔交易的 block_time
```

- 订单号

```
现货成交：用 order_hash（或 cid，若有）
充值/提现：用 tx_hash
```

- 账户余额 / 计算余额 / 余额差

同“资金管理”页口径，不重复展开。

# 理财

## 理财币种配置

### 表格字段

- **序号**

```
非链上，前端按列表顺序生成即可
```

- 币种

```
最佳获取（Query）：Query/AllLendingPools 返回的 LendingPool.denom 列表（接口：/injective/exchange/v2/spot_leverage/pools）。
可行性建议：若 UI 展示的“币种符号”≠链上 denom（例如 tokenfactory denom），需要链下映射把 denom 转成展示用 ticker。
```

- 当前年化收益率

```
最佳获取（Query）：LendingPool.supply_rate（Query/LendingPool 或 Query/AllLendingPools）。
```

- 最小申购金额

```
现状（Query，全局）：Query/SpotLeverageParams 的 SpotLeverageParams.min_supply_amount（接口：/injective/exchange/v2/spot_leverage/params），所有币种同一个值。

可行性建议（要做“按币种个性化”）：
在 exchange 模块内增加 denom 维度的池子参数存储/查询（现在已有 LendingPoolParamsPrefix 但未真正落地使用），例如新增 Query/LendingPoolParams(denom)、Query/AllLendingPoolParams，并提供 MsgUpdateLendingPoolParams{authority, denom, ...}。
实现上建议：全局参数做 default，denom 参数做 override（没配置就回退到全局），兼容你们现在“全局都一样”的现状。
```

- **状态**

```
链上现状：没有状态
可行性建议（最推荐）：引入 LendingPoolConfig{denom, enabled}（或把 enabled 放进你们新增的 denom 参数里），并在链上强制：
enabled=false 时禁止新申购/禁止新增借款（但允许赎回/允许还款，否则会锁死存量资金）。
```

- **创建时间 / 更新时间**

```
链上现状：没有
可行性建议：
若必须链上可查：在你们新增的 LendingPoolConfig / LendingPoolParams(denom) 里增加 created_at/updated_at（用 block time/height 写入），并在更新消息里同步刷新。
```

### 弹窗按钮

- 添加币种（产品中少了当前年化收益率，需要加上）

```
添加币种下的各类参数，都需要链上新增加一个创建池子的接口，并且做成个性化的，每个币种池子不一样，保留原先的各个池子全局统一默认参数（只是给链上自动创建池子准备的，后面大部分要通过 dex 管理后台进行管理）
```

- 编辑（产品中少了当前年化收益率，需要加上）

```
编辑下的各类参数，都需要链上新增加一个更新池子的接口，并且做成个性化的，每个币种池子不一样，保留原先的各个池子全局统一默认参数（只是给链上自动创建池子准备的，后面大部分要通过 dex 管理后台进行管理）
```

- 下架（产品少了一个上架）

```
上架和下架，其实对应修改的是池子的状态，当上架时可以正常运行，下架后，禁止新申购/禁止新增借款（但允许赎回/允许还款）。
```

==特殊说明==

添加，编辑，上架，下架，这些都要使用签名验证才可以。

## 理财记录

### 表格字段

- 订单号

```
直接用 tx_hash 当订单号（最简单）
```

- **用户 ID：链上没有**

```
链上可得：事件里的 supplier（Bech32 主账户地址）
可行性方案：链下维护 Uxxx <-> supplier(或其默认subaccount) 映射；你们若坚持“用户=子账户”，可由 supplier + nonce=0 推导默认 subaccount_id。
```

- 币种

```
链上可得：事件里的 denom
可行性方案：若 UI 需要 TSLA/SOL 这种 ticker，而链上是 factory/... denom，需要链下做 denom→展示符号映射
```

- 操作类型（去掉利息类型）

```
申购：MsgSupplyToLendingPool 成功后会发事件 "supply_to_lending_pool"（含 supplier/denom/amount/shares）
赎回：MsgWithdrawFromLendingPool 成功后会发事件 "withdraw_from_lending_pool"（含 supplier/denom/shares/amount）
```

- 数量：

```
申购：用事件里的 amount（注意这是链上最小单位口径字符串；需按 denom decimals 转人类可读）
赎回：用事件里的 amount（同上）
```

- 状态（只保留成功和失败）

```
成功：事件出现了即代表成功了。
失败：tx 返回非 0 code（需要你们采集 tx result，而不是只靠事件）
```

- 创建时间 / 完成时间

```
创建时间：前端“用户提交申请”的时间
完成时间：tx 上链时间（block_time）
```

### 弹窗按钮

- 查看详情

  - 订单信息、时间信息中的字段同上，已经梳理。下面是链上交易信息中的字段
  - 交易哈希

    ```
    最佳来源：事件监听时从该笔 tx 的上下文拿到 tx_hash，并与 "supply_to_lending_pool" / "withdraw_from_lending_pool" 事件落库关联。
    ```

  - 区块号

    ```
    最佳来源：同上，监听时记录 tx_height
    ```

  - 区块确认数

    ```
    计算方式：confirmations = latest_height - tx_height + 1（若 latest_height < tx_height 则显示 0/“-”）。
    latest_height 获取：cosmos.base.tendermint.v1beta1.Service/GetLatestBlock()
    ```

  - gas 费用

    ```
    链上可得：从 GetTx(tx_hash) 解析 tx.auth_info.fee.amount[]（通常是 INJ，可能多币种）。
    ```

  - 链上状态

    ```
    链上可得：GetTx(tx_hash).tx_response.code：0 => 成功，非 0 => 失败
    ```

  - 网络

    ```
    链上可得（技术值）：chain_id（可从 GetLatestBlock().block.header.chain_id 或 GetNodeInfo() 取得）。
    产品展示（人类可读）：把 chain_id 映射成“Injective Mainnet/Testnet”等（通常是你们配置/常量表，不是链上直接给的中文名）。
    ```

- **查看链上交易**

```
需要区块链浏览器的支持。
实现：用 network(chain_id) 选择浏览器前缀 + tx_hash 拼出区块浏览器链接（链上不提供 explorer URL，本质是前端配置）。
```

## 理财统计

### 卡片字段

- 总申购金额

```
链上来源（事件）："supply_to_lending_pool"（supplier/denom/amount/shares）
实现口径：对选定统计周期内所有申购 amount 求和。
若展示 $/USDT 计价：需要链下把 denom amount 转 USDT（价格来源见下“价格换算”）。
```

- 总赎回金额

```
链上来源（事件）："withdraw_from_lending_pool"（supplier/denom/shares/amount）
实现口径：对统计周期内所有赎回 amount 求和（同样需要做 USDT 换算）。
```

- **总收益**

```
可行口径（平台总收益，推荐）：监听 "interest_distributed" 事件（denom/total_interest/platform_share/suppliers_share），把 suppliers_share 按周期求和（再做 USDT 换算）。
注意：该事件主要由 BeginBlockerSpotLeverage 每小时 AccrueInterest 触发；另外借款预收利息时也会触发一次分配（因此不严格等于“每小时恰好一条”）。
```

- **活跃用户数**

```
链上来源（事件聚合）：统计周期内 supplier 去重计数（来自申购/赎回事件）。
```

### 表格字段

- **用户 ID：链上没有**

```
链上可得：事件里的 supplier（Bech32 主账户地址）
可行性方案：链下维护 Uxxx <-> supplier(或其默认subaccount) 映射；你们若坚持“用户=子账户”，可由 supplier + nonce=0 推导默认 subaccount_id。
```

- 申购金额

```
链上来源（事件）："supply_to_lending_pool" 按 supplier 聚合求和。
若展示 $/USDT：需要价格换算（见下）。
```

- 赎回金额

```
链上来源（事件）："withdraw_from_lending_pool" 按 supplier 聚合求和。
若展示 $/USDT：需要价格换算（见下）。
```

- 净申购

```
链下计算：申购金额 - 赎回金额（同口径/同计价）。
```

- **总收益**

```
链下按事件回放维护每个用户的 principal/shares；每次赎回用“赎回金额 - 本次赎回对应本金”得到已实现收益并累计；再加上“当前未提现收益”。
```

==价格换算与精度（若页面金额要用 $/USDT）==

decimals：事件里的 amount 是最小单位口径字符串，需要用 Query/AuctionExchangeTransferDenomDecimals 做精度还原。

价格来源（链上）：优先用 exchange.Query/SpotMidPriceAndTOB（有对应现货市场时），否则用 oracle 价格（如有喂价）；链上一般不提供“历史价格查询”，所以常见做法是在监听事件入库时同步记录当时价格快照用于统计。

## 资金池

### 表格字段

- 币种

```
最佳（Query）：exchange.Query/AllLendingPools 返回 LendingPool.denom 列表（每条一个币种池子）。
```

- 池子总资金量

```
最佳（Query）：LendingPool.total_supply（来自 AllLendingPools 或 LendingPool(denom)）。
注意精度：这里是最小单位口径（LegacyDec），展示要按 Query/AuctionExchangeTransferDenomDecimals 还原 decimals。
```

- 已借出总量

```
最佳（Query）：LendingPool.total_borrowed（同上）。
```

- 资金利用率

```
最佳（Query）：LendingPool.utilization_rate（链上已算好）。
```

- 借款年化利率

```
最佳（Query）：LendingPool.borrow_rate（年化）。
```

- 存款年化利率

```
最佳（Query）：LendingPool.supply_rate（年化）。
```

- **质押用户数：链上现状：没有 Query 可直接得到**

```
可行方案（改链）：链上维护 per-denom staker_count（在申购/赎回导致 shares 从 0→>0、>0→0 时增减），并在 LendingPool Query 里返回或新增 LendingPoolStats Query。
```

- **借款用户数：链上现状：没有 Query 可直接得到**

```
可行方案（改链，最干净）：链上维护 per-denom borrower_count（在借款记录创建/删除时增减），并对外 Query。
```

- **更新时间：链上现状：没有更新时间**

```
可行方案（改链）：为 LendingPool 增加 last_update_time（在 supply/withdraw/borrow/repay/interest accrual 发生时更新），Query 直接返回。
```

### 弹窗按钮

- 查看详情

  - 池子基本信息（币种、池子总资金量、已借出总量、资金利用率、质押用户数、借款用户数）：同上，已经梳理
  - 池子基本信息（可用资金）

    ```
    链上获取（Query）：exchange.Query/LendingPool(denom) 的 pool.total_supply 与 pool.total_borrowed
    计算：available = total_supply - total_borrowed
    ```

  - 利率信息（借款年化利率、存款年化利率）：同上，已经梳理
  - 利率信息（基础利率 / 最优利用率 / 第一段斜率 / 第二段斜率 / 协议抽成）

    ```
    链上获取（Query）：exchange.Query/SpotLeverageParams
    base_interest_rate / optimal_utilization_rate / interest_rate_slope1 / interest_rate_slope2 / platform_share_ratio

    重要说明：当前实现这些都是全局参数（所有币种池子相同；非按 denom 配置），后面每个币种池子都有自己独立的创建接口和个性化参数
    ```

  - **收益统计（累计借款利息收入 / 累计质押收益分配 / 今日借款利息 / 今日质押收益）**

    ```
    链上现状：无直接 Query

    可行方案（推荐，链下聚合）：监听 SDK 事件 interest_distributed（在 distributeInterest 里发；主要每小时触发，借款预收费也会触发）
    attributes：denom / total_interest / platform_share / suppliers_share
    累计：对历史事件按 denom 累加
    今日：按 block_time 落到“当天”做日聚合（你们需统一用 UTC 还是北京时间）
    精度：这些金额是该 denom 的最小单位字符串，需要按 Query/AuctionExchangeTransferDenomDecimals 还原
    ```

  - 收益统计（累计协议抽成）

    ```
    链上获取（Query，最直接）：exchange.Query/LendingPool(denom) 的 pool.reserve_amount（准备金累计值）
    ```

  - **收益统计（下次结算时间）**

    ```
    链上现状：无字段
    可行方案（链下近似）：按当前实现“每小时一次”给出估算：
    按 block_height%600==0 的逻辑推下一个触发高度并用平均出块时间估算到达时间
    ```

  - 链上信息（网络）

    ```
    链上获取（Query）：Tendermint GetLatestBlock/GetNodeInfo 取 chain_id，前端映射成“Mainnet/Testnet”等展示名
    ```

  - **链上信息（合约地址）**

    ```
    需要使用到预编译合约，待定
    ```

  - 链上信息（最后更新时间）

    ```
    同上面的更新时间
    ```

- 查看历史利率

  - 时间

    ```
    链上字段：LendingRateSnapshot.snapshot_time（Unix 秒，整点截断）
    获取方式：Query/LendingRateHistory → snapshots[].snapshot_time
    ```

  - 资金利用率

    ```
    链上字段：LendingRateSnapshot.utilization_rate（小数，如 0.75）
    展示：utilization_rate * 100 → 75.00%
    ```

  - 借款年化利率

    ```
    链上字段：LendingRateSnapshot.borrow_rate（小数年化，如 0.2075）
    展示：borrow_rate * 100 → 20.75%
    ```

  - 存款年化利率

    ```
    链上字段：LendingRateSnapshot.supply_rate（小数年化）
    展示：supply_rate * 100
    ```

  - **池子总资金量、已借出总量**

    ```
    改动 1：扩展快照结构
    在 proto/injective/exchange/v2/spot_leverage.proto 的 LendingRateSnapshot 增加字段：
    total_supply
    total_borrowed
    同时更新 keeper 内部的 LendingRateSnapshot（Go struct）与序列化落库逻辑（当前用 JSON 存，新增字段兼容；旧数据没有这两个字段会显示为 0）。
    改动 2：写入快照时补齐 supply/borrow
    在每小时的 RecordLendingRateSnapshots 里，除了记录 borrow_rate/supply_rate/utilization_rate，同时把当时 pool.total_supply/pool.total_borrowed 写进快照。
    改动 3：把时间范围/limit 语义做对
    实现 start_time/end_time 过滤（目前忽略）。
    建议把 limit 语义改为“返回最新 N 条”（或新增 descending/latest 参数），否则前端分页/默认展示会很别扭。
    如果你们想支持更长历史，把当前“每币种只保留 168 条（7天×24小时）”的上限做成参数（或直接调大）。
    ```

- **查看合约**

```
需要使用到预编译合约，待定
```

## 资金池统计

### 表格字段

注意：该页面字段多为“累计/统计”口径（且原型包含时间范围筛选），与“资金池页面”的“当前快照”口径不同，不能简单复用。

- 币种

```
最佳来源（Query）：exchange.Query/AllLendingPools
链上字段：LendingPool.denom
```

- **累计存入**

```
链上现状：无直接 Query（LendingPool.total_supply 是“当前余额”，非累计流入）
最佳方案（事件聚合，推荐）：监听 "supply_to_lending_pool"
聚合口径：按 denom 对事件属性 amount 求和（可按时间范围过滤）
事件属性：supplier / denom / amount / shares
```

- **累计借出**

```
链上现状：无直接 Query（LendingPool.total_borrowed 是“当前借出本金余额”，非累计发生额）
最佳方案（事件聚合，推荐）：监听 "spot_leverage_borrow"
聚合口径：按 denom 对事件属性 amount 求和（可按时间范围过滤）
事件属性：subaccount_id / denom / amount / prepaid_interest
```

- **存入人数**

```
链上现状：无直接 Query
最佳方案（事件聚合，推荐）：监听 "supply_to_lending_pool"
聚合口径（建议与产品确认）：
1）若口径为“累计存入用户数（去重）”：统计时间范围内 supplier 去重数量（按 denom 分组）
2）若口径为“当前仍在存入的用户数”：需要额外维护供应者 shares 是否 >0（链上无直接 Query），建议链下索引供给/赎回事件维护状态
```

- **借出人数**

```
链上现状：无直接 Query
最佳方案（事件聚合，推荐）：监听 "spot_leverage_borrow"
聚合口径（建议与产品确认）：
1）累计借出用户数：统计时间范围内 subaccount_id 去重数量（按 denom 分组）
2）当前仍在借款用户数：需要借/还事件维护“未清仓借款记录”的集合（链上无直接 Query 返回人数）
```

- **借款利息收入**

```
最佳方案（事件聚合，推荐）：监听每次利息分配产生的 "interest_distributed"
聚合口径：按 denom 对 total_interest 求和（可按时间范围过滤）
事件属性：denom / total_interest / platform_share / suppliers_share
```

- **质押利息分配**

```
最佳方案（事件聚合，推荐）：同上 "interest_distributed"
聚合口径：按 denom 对 suppliers_share 求和（可按时间范围过滤）
```

- **协议抽成**

```
时间范围统计（推荐）：监听 "interest_distributed"，按 denom 汇总 platform_share

累计到当前（可直接 Query，口径为“准备金累计值”）：
exchange.Query/LendingPool(denom) -> LendingPool.reserve_amount
注意：reserve_amount 无法直接做“时间范围内新增”，要做区间仍需事件/快照
```

# 整体说明

1. 当发现某些数据无法直接获得的时候，改不改链需要根据频率来定，比如订单、资金这种需要二次聚合统计这种，就不适合链上做，不然链性能不好，但是某些类静态字段，或者是通过查询就可以直接得到的，比如池子的信息，就可以改。
2. 某些模块可能会共用一些事件监听，比如资金明细可能会用到订单明细，这种的优先开发，不要重复监听。
3. 公共的东西要抽出来复用，不要各个模块各来一套。
4. 数据库统一，用大数据 MPP 架构数据库（Doris），不要有的在 Doris，有的在 MySQL，你还要考虑到后续可能会有多表联查一类的业务，放在一起就行，普通业务能做到的查询，大数据都能做。
5. 缓存统一用 Redis，尤其是那种页面点进去就有列表数据的，但要注意定期将缓存和 Doris 进行同步。
6. 编程语言统一用 go，路由统一为 gin，doris 本身就兼容 MySQL 协议，在 go 侧直接用 database/sql + github.com/go-sql-driver/mysql 连接即可（gorm 可用但建议弱化，因为 gorm 主要用于简单的 curd，复杂筛选和查询建议还是 raw sql 为主）
7. Kafka 作为消息中间件，起到削峰填谷的作用，持久化也方便重放与容灾，比起每次都要重新扫链上块，要高效很多。数据缓存建议默认 7 天即可（后期可调）
8. 其他中间件，看业务需要再调整。
